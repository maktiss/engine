#pragma once

#include "engine/managers/MeshManager.hpp"
#include "engine/managers/ShaderManager.hpp"
#include "engine/managers/TextureManager.hpp"

#define VULKAN_HPP_NO_EXCEPTIONS 1
#include <vulkan/vulkan.hpp>

#include <vector>


namespace Engine::Renderers {
class RendererBase {
public:
	// TODO: better name?
	struct AttachmentDescription {
		vk::Format format;
		vk::ImageUsageFlags usage;
	};

	struct AttachmentReference {
		uint rendererIndex {};
		uint outputIndex {};
	};

protected:
	std::vector<AttachmentReference> outputs {};
	std::vector<AttachmentReference> inputs {};

	vk::Device vkDevice {};

	vk::Extent2D outputSize {};

	std::vector<AttachmentDescription> outputDescriptions {};
	std::vector<AttachmentDescription> inputDescriptions {};


	// Requested by RenderingSystem to create render pass
	std::vector<vk::AttachmentDescription> vkAttachmentDescriptions {};
	std::vector<vk::AttachmentReference> vkAttachmentReferences {};
	vk::PipelineBindPoint VkPipelineBindPoint {};


	// TODO: split into GraphicsRenderer and ComputeRenderer
	// Requested by RenderingSystem to create graphics pipelines
	vk::PipelineInputAssemblyStateCreateInfo vkPipelineInputAssemblyStateCreateInfo {};
	vk::Viewport vkViewport {};
	vk::Rect2D vkScissor {};
	vk::PipelineRasterizationStateCreateInfo vkPipelineRasterizationStateCreateInfo {};
	vk::PipelineMultisampleStateCreateInfo vkPipelineMultisampleStateCreateInfo {};
	vk::PipelineColorBlendAttachmentState vkPipelineColorBlendAttachmentState {};


	// Generated by RenderingSystem
	// vk::Framebuffer vkFramebuffer {};
	std::vector<vk::Pipeline> vkGraphicsPipelines {};

	uint threadCount		 = 1;
	uint framesInFlightCount = 3;


public:
	virtual int init() = 0;

	// virtual int run(double dt, uint frameIndex) = 0;
	virtual void recordCommandBuffer(double dt, vk::CommandBuffer& commandBuffer) = 0;

	virtual const char* getRenderPassName() const = 0;


	inline const auto& getOutputs() const {
		return outputs;
	}

	inline const auto& getInputs() const {
		return inputs;
	}


	void setVkDevice(vk::Device device) {
		vkDevice = device;
	}

	void setOutputSize(vk::Extent2D extent) {
		outputSize = extent;
	}


	void setThreadCount(uint count) {
		threadCount = count;
	}

	void setFramesInFlightCount(uint count) {
		framesInFlightCount = count;
	}


	// void setVkFramebuffer(vk::Framebuffer framebuffer) {
	// 	vkFramebuffer = framebuffer;
	// }

	// auto getVkFramebuffer() const {
	// 	return vkFramebuffer;
	// }


	void setGraphicsPipelines(std::vector<vk::Pipeline>& graphicsPipelines) {
		vkGraphicsPipelines = graphicsPipelines;
	}


	const auto& getOutputDescriptions() const {
		return outputDescriptions;
	}

	const auto& getInputDescriptions() const {
		return inputDescriptions;
	}


	const auto& getVkAttachmentDescriptions() const {
		return vkAttachmentDescriptions;
	}

	const auto& getVkAttachmentReferences() const {
		return vkAttachmentReferences;
	}

	const auto& getVkPipelineBindPoint() const {
		return VkPipelineBindPoint;
	}


	const auto& getVkPipelineInputAssemblyStateCreateInfo() {
		return vkPipelineInputAssemblyStateCreateInfo;
	}
	
	const auto& getVkViewport() {
		return vkViewport;
	}
	
	const auto& getVkScissor() {
		return vkScissor;
	}
	
	const auto& getVkPipelineRasterizationStateCreateInfo() {
		return vkPipelineRasterizationStateCreateInfo;
	}
	
	const auto& getVkPipelineMultisampleStateCreateInfo() {
		return vkPipelineMultisampleStateCreateInfo;
	}
	
	const auto& getVkPipelineColorBlendAttachmentState() {
		return vkPipelineColorBlendAttachmentState;
	}


	// int allocateCommandBuffers(std::vector<vk::CommandPool> commandPools) {
	// 	vkCommandBuffers.resize(framesInFlightCount * threadCount);
	// 	assert(vkCommandBuffers.size() == commandPools.size());

	// 	for (uint i = 0; i < vkCommandBuffers.size(); i++) {
	// 		vk::CommandBufferAllocateInfo commandBufferAllocateInfo {};
	// 		commandBufferAllocateInfo.commandPool = commandPools[i];
	// 		// TODO: secondary buffers for threads
	// 		commandBufferAllocateInfo.level				 = vk::CommandBufferLevel::ePrimary;
	// 		commandBufferAllocateInfo.commandBufferCount = 1;

	// 		vk::CommandBuffer commandBuffer;
	// 		auto result = vkDevice.allocateCommandBuffers(&commandBufferAllocateInfo, &vkCommandBuffers[i]);
	// 		if (result != vk::Result::eSuccess) {
	// 			spdlog::error("[ForwardRenderer] Failed to allocate command buffer. Error code: {} ({})",
	// 						  result,
	// 						  vk::to_string(result));
	// 			return 1;
	// 		}
	// 	}

	// 	return 0;
	// }


protected:
	// vk::CommandBuffer getCommandBuffer(uint frameIndex, uint threadIndex) {
	// 	return vkCommandBuffers[frameIndex * threadCount + threadIndex];
	// }
};
} // namespace Engine::Renderers