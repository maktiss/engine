#pragma once

#include "engine/managers/MeshManager.hpp"
#include "engine/managers/ShaderManager.hpp"
#include "engine/managers/TextureManager.hpp"

#include "engine/graphics/UniqueUniformBuffer.hpp"

#include "engine/utils/VulkanHelper.hpp"

#define VULKAN_HPP_NO_EXCEPTIONS 1
#include <vulkan/vulkan.hpp>

#include "vk_mem_alloc.h"

#include <vector>


namespace Engine::Renderers {
class RendererBase {
public:
	// TODO: better name?
	struct AttachmentDescription {
		vk::Format format;
		vk::ImageUsageFlags usage;
	};

	struct AttachmentReference {
		uint rendererIndex {};
		uint outputIndex {};
	};


protected:
	std::vector<AttachmentReference> outputs {};
	std::vector<AttachmentReference> inputs {};

	vk::Device vkDevice {};

	vk::Extent2D outputSize {};
	
	VmaAllocator vmaAllocator {};

	std::vector<AttachmentDescription> outputDescriptions {};
	std::vector<AttachmentDescription> inputDescriptions {};

	std::vector<vk::ClearValue> vkClearValues {};

	std::vector<Engine::Graphics::UniqueUniformBuffer> uniformBuffers {};

	// Requested by RenderingSystem to create render pass
	std::vector<vk::AttachmentDescription> vkAttachmentDescriptions {};
	std::vector<vk::AttachmentReference> vkAttachmentReferences {};
	vk::PipelineBindPoint VkPipelineBindPoint {};

	// TODO: split into GraphicsRenderer and ComputeRenderer
	// Requested by RenderingSystem to create graphics pipelines
	vk::PipelineInputAssemblyStateCreateInfo vkPipelineInputAssemblyStateCreateInfo {};
	vk::Viewport vkViewport {};
	vk::Rect2D vkScissor {};
	vk::PipelineRasterizationStateCreateInfo vkPipelineRasterizationStateCreateInfo {};
	vk::PipelineMultisampleStateCreateInfo vkPipelineMultisampleStateCreateInfo {};
	vk::PipelineDepthStencilStateCreateInfo vkPipelineDepthStencilStateCreateInfo {};
	vk::PipelineColorBlendAttachmentState vkPipelineColorBlendAttachmentState {};

	// Generated by RenderingSystem
	vk::PipelineLayout vkPipelineLayout {};
	std::vector<vk::Pipeline> vkGraphicsPipelines {};

	uint threadCount		 = 1;
	uint framesInFlightCount = 3;


public:
	virtual int init() = 0;

	virtual void recordCommandBuffer(double dt, vk::CommandBuffer& commandBuffer) = 0;

	virtual const char* getRenderPassName() const = 0;


	inline const auto& getOutputs() const {
		return outputs;
	}

	inline const auto& getInputs() const {
		return inputs;
	}


	void setVkDevice(vk::Device device) {
		vkDevice = device;
	}

	void setOutputSize(vk::Extent2D extent) {
		outputSize = extent;
	}

	void setVulkanMemoryAllocator(VmaAllocator allocator) {
		vmaAllocator = allocator;
	}


	void setThreadCount(uint count) {
		threadCount = count;
	}

	void setFramesInFlightCount(uint count) {
		framesInFlightCount = count;
	}


	void setVkPipelineLayout(vk::PipelineLayout pipelineLayout) {
		vkPipelineLayout = pipelineLayout;
	}

	void setGraphicsPipelines(std::vector<vk::Pipeline>& graphicsPipelines) {
		vkGraphicsPipelines = graphicsPipelines;
	}


	const auto& getOutputDescriptions() const {
		return outputDescriptions;
	}

	const auto& getInputDescriptions() const {
		return inputDescriptions;
	}

	const auto& getVkClearValues() const {
		return vkClearValues;
	}


	const auto& getVkAttachmentDescriptions() const {
		return vkAttachmentDescriptions;
	}

	const auto& getVkAttachmentReferences() const {
		return vkAttachmentReferences;
	}

	const auto& getVkPipelineBindPoint() const {
		return VkPipelineBindPoint;
	}


	const auto& getVkPipelineInputAssemblyStateCreateInfo() {
		return vkPipelineInputAssemblyStateCreateInfo;
	}

	const auto& getVkViewport() {
		return vkViewport;
	}

	const auto& getVkScissor() {
		return vkScissor;
	}

	const auto& getVkPipelineRasterizationStateCreateInfo() {
		return vkPipelineRasterizationStateCreateInfo;
	}

	const auto& getVkPipelineMultisampleStateCreateInfo() {
		return vkPipelineMultisampleStateCreateInfo;
	}

	const auto& getVkPipelineDepthStencilStateCreateInfo() {
		return vkPipelineDepthStencilStateCreateInfo;
	}

	const auto& getVkPipelineColorBlendAttachmentState() {
		return vkPipelineColorBlendAttachmentState;
	}


	const auto getVkDescriptorSetLayouts() {
		std::vector<vk::DescriptorSetLayout> layouts(uniformBuffers.size());
		for (uint i = 0; i < layouts.size(); i++) {
			layouts[i] = uniformBuffers[i].getVkDescriptorSetLayout();
		}
		return layouts;
	}


	void dispose() {
		for (auto& uniformBuffer : uniformBuffers) {
			uniformBuffer.dispose();
		}
	}
};
} // namespace Engine::Renderers